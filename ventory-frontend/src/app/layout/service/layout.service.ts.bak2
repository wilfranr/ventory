import { Injectable, effect, signal, computed, inject } from '@angular/core';
import { Subject } from 'rxjs';
import { CompanyThemeService } from '../../services/company-theme.service';
import { SessionService } from '../../services/session.service';
import { CompanyContextService } from '../../services/company-context.service';

export interface layoutConfig {
    preset?: string;
    primary?: string;
    surface?: string | undefined | null;
    darkTheme?: boolean;
    menuMode?: string;
}

interface LayoutState {
    staticMenuDesktopInactive?: boolean;
    overlayMenuActive?: boolean;
    configSidebarVisible?: boolean;
    staticMenuMobileActive?: boolean;
    menuHoverActive?: boolean;
}

interface MenuChangeEvent {
    key: string;
    routeEvent?: boolean;
}

@Injectable({
    providedIn: 'root'
})
export class LayoutService {
    private companyThemeService = inject(CompanyThemeService);
    private sessionService = inject(SessionService);
    private companyContextService = inject(CompanyContextService);
    
    // Contexto para distinguir entre cambios de usuario y cambios de empresa
    private isCompanyContext = signal<boolean>(false);
    private currentCompanyId = signal<string | null>(null);

    // MÃ©todos para establecer el contexto de empresa
    setCompanyContext(companyId: string): void {
        this.isCompanyContext.set(true);
        this.currentCompanyId.set(companyId);
    }

    clearCompanyContext(): void {
        this.isCompanyContext.set(false);
        this.currentCompanyId.set(null);
    }

    // MÃ©todo para recargar estilos cuando cambie la empresa activa
    reloadCompanyTheme(): void {
        this.loadCompanyTheme();
    }

    _config: layoutConfig = {
        preset: 'Aura',
        primary: 'emerald',
        surface: null,
        darkTheme: false,
        menuMode: 'static'
    };

    _state: LayoutState = {
        staticMenuDesktopInactive: false,
        overlayMenuActive: false,
        configSidebarVisible: false,
        staticMenuMobileActive: false,
        menuHoverActive: false
    };

    layoutConfig = signal<layoutConfig>(this._config);

    layoutState = signal<LayoutState>(this._state);

    private configUpdate = new Subject<layoutConfig>();

    private overlayOpen = new Subject<any>();

    private menuSource = new Subject<MenuChangeEvent>();

    private resetSource = new Subject();

    menuSource$ = this.menuSource.asObservable();

    resetSource$ = this.resetSource.asObservable();

    configUpdate$ = this.configUpdate.asObservable();

    overlayOpen$ = this.overlayOpen.asObservable();

    theme = computed(() => (this.layoutConfig()?.darkTheme ? 'light' : 'dark'));

    isSidebarActive = computed(() => this.layoutState().overlayMenuActive || this.layoutState().staticMenuMobileActive);

    isDarkTheme = computed(() => this.layoutConfig().darkTheme);

    getPrimary = computed(() => this.layoutConfig().primary);

    getSurface = computed(() => this.layoutConfig().surface);

    isOverlay = computed(() => this.layoutConfig().menuMode === 'overlay');

    transitionComplete = signal<boolean>(false);

    private initialized = false;
    private isFirstLoad = true;

    constructor() {
        // ðŸ§¹ Limpiar estilos obsoletos del localStorage
        this.cleanupOldThemeData();
        
        // ðŸŽ¯ Carga inicial inmediata basada en SessionService
        this.loadCompanyTheme();
        
        // ðŸŽ¯ Suscribirse a cambios de empresa activa para recargas posteriores
        this.companyContextService.activeCompanyId$.subscribe(companyId => {
            if (companyId && !this.isFirstLoad) {
                console.log('ðŸ”„ Empresa activa cambiÃ³, recargando estilos:', companyId);
                this.loadCompanyTheme();
            } else if (!companyId && !this.isFirstLoad) {
                // Solo usar fallback si NO es la primera carga y no hay empresa activa
                console.log('âš ï¸ Empresa activa se perdiÃ³, usando estilos por defecto');
                this.loadFallbackTheme();
            }
        });

        // ðŸŽ¯ Efectos reactivos
        effect(() => {
            const config = this.layoutConfig();
            if (config) {
                this.onConfigUpdate();
            }
        });

        effect(() => {
            const config = this.layoutConfig();

            if (!this.initialized || !config) {
                this.initialized = true;
                return;
            }

            this.handleDarkModeTransition(config);
        });
    }

    private loadCompanyTheme() {
        try {
            // Priorizar empresa de la sesiÃ³n sobre empresa activa para evitar conflictos
            const sessionCompanyId = this.sessionService.companyId;
            const activeCompanyId = this.companyContextService.getActiveCompanyId();
            
            // Validar que el ID de la empresa sea vÃ¡lido
            const companyId = (sessionCompanyId && sessionCompanyId.trim() !== '') 
                ? sessionCompanyId.trim() 
                : (activeCompanyId && activeCompanyId.trim() !== '' ? activeCompanyId.trim() : null);
            
            // Debug detallado para identificar el problema
            console.log('ðŸ” Debug carga de estilos:', {
                activeCompanyId,
                sessionCompanyId,
                selectedCompanyId: companyId,
                sessionServiceExists: !!this.sessionService,
                companyContextServiceExists: !!this.companyContextService
            });
            
            if (companyId) {
                this.companyThemeService.getThemeSettings(companyId).subscribe({
                    next: (theme) => {
                        // Solo mostrar Ã©xito en la primera carga
                        if (this.isFirstLoad) {
                            console.log('âœ… Estilos cargados para empresa:', companyId, theme);
                            this.isFirstLoad = false;
                        }
                        this.applyCompanyTheme(theme);
                        // Cargar tema del usuario despuÃ©s de aplicar estilos de empresa
                        this.loadUserThemeMode();
                    },
                    error: (error) => {
                        console.warn('âŒ No se pudieron cargar los estilos de la empresa, usando valores por defecto. Error:', error);
                        // Limpiar empresa invÃ¡lida del almacenamiento
                        if (error.status === 400) {
                            console.log('ðŸ§¹ Limpiando ID de empresa invÃ¡lido del almacenamiento');
                            this.companyContextService.clearActiveCompany();
                            localStorage.removeItem('user');
                        }
                        this.loadFallbackTheme();
                    }
                });
            } else {
                // Solo usar fallback en la primera carga si no hay empresa
                if (this.isFirstLoad) {
                    console.log('âš ï¸ No hay empresa activa en la primera carga, usando estilos por defecto');
                    this.loadFallbackTheme();
                } else {
                    console.log('âš ï¸ No hay empresa activa, manteniendo estilos actuales');
                }
            }
        } catch (error) {
            console.error('âŒ Error inesperado al cargar el tema de la empresa:', error);
            this.loadFallbackTheme();
        }
    }

    private loadUserThemeMode() {
        // Verificar si ya hay un tema cargado para evitar sobrescribir
        if (this.layoutConfig().darkTheme !== undefined) {
            return;
        }

        const savedTheme = localStorage.getItem('theme-mode');
        console.log('ðŸŒ™ Cargando modo de tema desde localStorage:', savedTheme);
        
        const isDarkMode = savedTheme === 'dark';
        
        // Usar una sola actualizaciÃ³n del estado
        this.layoutConfig.update(state => ({
            ...state,
            darkTheme: isDarkMode
        }));

        // Aplicar la clase al documento
        if (isDarkMode) {
            document.documentElement.classList.add('app-dark');
        } else {
            document.documentElement.classList.remove('app-dark');
        }
        
        console.log('ðŸŒ™ Modo de tema aplicado:', isDarkMode ? 'oscuro' : 'claro');
    }

    private applyCompanyTheme(theme: any) {
        console.log('ðŸŽ¨ Aplicando estilos de empresa:', theme);
        
        // Preservar el estado actual del tema oscuro
        const currentDarkTheme = this.layoutConfig().darkTheme;
        
        // Aplicar colores directamente al root del documento
        if (theme.themePrimary) {
            const primaryColor = theme.themePrimary;
            document.documentElement.style.setProperty('--primary-color', primaryColor);
            document.documentElement.style.setProperty('--primary-color-dark', this.adjustColor(primaryColor, -20));
            document.documentElement.style.setProperty('--primary-color-light', this.adjustColor(primaryColor, 20));
            
            // Aplicar estilos adicionales para PrimeNG
            const style = document.createElement('style');
            style.id = 'custom-theme-styles';
            style.textContent = `
                .p-button {
                    background: ${primaryColor} !important;
                    border-color: ${primaryColor} !important;
                }
                .p-button:enabled:hover {
                    background: ${this.adjustColor(primaryColor, -10)} !important;
                    border-color: ${this.adjustColor(primaryColor, -10)} !important;
                }
                .p-button:focus {
                    box-shadow: 0 0 0 0.2rem ${this.adjustColor(primaryColor, 40)} !important;
                }
            `;
            
            // Eliminar estilos anteriores si existen
            const existingStyle = document.getElementById('custom-theme-styles');
            if (existingStyle) {
                document.head.removeChild(existingStyle);
            }
            document.head.appendChild(style);
        }
        
        if (theme.themeSurface) {
            document.documentElement.style.setProperty('--surface-ground', theme.themeSurface);
        }

        // Crear un nuevo objeto de configuraciÃ³n con los valores de la empresa
        const newConfig = {
            ...this.layoutConfig(),
            ...(theme.themePreset && { preset: theme.themePreset }),
            ...(theme.themePrimary && { primary: theme.themePrimary }),
            ...(theme.themeSurface && { surface: theme.themeSurface }),
            ...(theme.menuMode && { menuMode: theme.menuMode }),
            // Mantener el estado actual del tema oscuro
            darkTheme: currentDarkTheme
        };

        console.log('ðŸŽ¨ Nueva configuraciÃ³n aplicada:', newConfig);
        this.layoutConfig.set(newConfig);
    }
    
    // FunciÃ³n auxiliar para ajustar el brillo de un color
    private adjustColor(color: string, amount: number): string {
        // Convertir el color a RGB
        let r = parseInt(color.substr(1, 2), 16);
        let g = parseInt(color.substr(3, 2), 16);
        let b = parseInt(color.substr(5, 2), 16);
        
        // Ajustar el brillo
        r = Math.max(0, Math.min(255, r + amount));
        g = Math.max(0, Math.min(255, g + amount));
        b = Math.max(0, Math.min(255, b + amount));
        
        // Volver a convertir a formato hexadecimal
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }
    }

    private cleanupOldThemeData() {
        // ðŸ§¹ Limpiar estilos obsoletos del localStorage que pueden causar conflictos
        const keysToRemove = [
            'theme-preset',
            'theme-primary', 
            'theme-surface',
            'theme-menu-mode'
        ];
        
        keysToRemove.forEach(key => {
            if (localStorage.getItem(key)) {
                console.log('ðŸ§¹ Limpiando estilo obsoleto:', key);
                localStorage.removeItem(key);
            }
        });
    }

    private loadFallbackTheme() {
        try {
            // ðŸŸ¢ Fallback: Solo cargar themeMode desde localStorage (preferencia personal)
            const savedTheme = localStorage.getItem('theme-mode');
            const isDarkMode = savedTheme === 'dark';
            
            // Aplicar tema oscuro si estÃ¡ configurado
            if (isDarkMode) {
                this.layoutConfig.update(state => ({ ...state, darkTheme: true }));
                document.documentElement.classList.add('app-dark');
            } else {
                this.layoutConfig.update(state => ({ ...state, darkTheme: false }));
                document.documentElement.classList.remove('app-dark');
            }
            
            // Aplicar colores por defecto
            const defaultConfig = {
                preset: 'Aura',
                primary: 'emerald',
                surface: null,
                menuMode: 'static'
            };
            
            this.layoutConfig.update(state => ({
                ...state,
                ...defaultConfig
            }));
            
            console.log('âœ… Tema por defecto cargado correctamente');
        } catch (error) {
            console.error('âŒ Error al cargar el tema por defecto:', error);
            
            // Asegurarse de que al menos el tema oscuro/claro estÃ© configurado
            document.documentElement.classList.remove('app-dark');
            this.layoutConfig.update(state => ({
                ...state,
                darkTheme: false,
                preset: 'Aura',
                primary: 'emerald',
                surface: null,
                menuMode: 'static'
            }));
        }
    }

    handleDarkModeTransition(config: layoutConfig) {
        // Solo actualizar si hay un cambio real
        const isDark = config.darkTheme === true;
        const currentIsDark = document.documentElement.classList.contains('app-dark');
        
        if (isDark !== currentIsDark) {
            if (isDark) {
                document.documentElement.classList.add('app-dark');
            } else {
                document.documentElement.classList.remove('app-dark');
            }
            
            // Solo guardar si realmente hay un cambio
            localStorage.setItem('theme-mode', isDark ? 'dark' : 'light');
            console.log('ðŸŒ™ Tema actualizado a:', isDark ? 'oscuro' : 'claro');
        }
    }
    private startViewTransition(config: layoutConfig): void {
        const transition = (document as any).startViewTransition(() => {
            this.toggleDarkMode(config);
        });

        transition.ready
            .then(() => {
                this.onTransitionEnd();
            })
            .catch(() => {});
    }

    toggleDarkMode(config?: layoutConfig): void {
        const _config = config || this.layoutConfig();

        if (_config.darkTheme) {
            document.documentElement.classList.add('app-dark');
        } else {
            document.documentElement.classList.remove('app-dark');
        }
        
        // ðŸŽ¨ themeMode es preferencia personal, se guarda solo en localStorage
        const themeMode = _config.darkTheme ? 'dark' : 'light';
        localStorage.setItem('theme-mode', themeMode);
    }
    private onTransitionEnd() {
        this.transitionComplete.set(true);
        setTimeout(() => {
            this.transitionComplete.set(false);
        });
    }

    onMenuToggle() {
        if (this.isOverlay()) {
            this.layoutState.update((prev) => ({ ...prev, overlayMenuActive: !this.layoutState().overlayMenuActive }));

            if (this.layoutState().overlayMenuActive) {
                this.overlayOpen.next(null);
            }
        }

        if (this.isDesktop()) {
            this.layoutState.update((prev) => ({ ...prev, staticMenuDesktopInactive: !this.layoutState().staticMenuDesktopInactive }));
        } else {
            this.layoutState.update((prev) => ({ ...prev, staticMenuMobileActive: !this.layoutState().staticMenuMobileActive }));

            if (this.layoutState().staticMenuMobileActive) {
                this.overlayOpen.next(null);
            }
        }
    }

    isDesktop() {
        return window.innerWidth > 991;
    }

    isMobile() {
        return !this.isDesktop();
    }

    onConfigUpdate() {
        this._config = { ...this.layoutConfig() };
        this.configUpdate.next(this.layoutConfig());
    }

    onMenuStateChange(event: MenuChangeEvent) {
        this.menuSource.next(event);
    }

    reset() {
        this.resetSource.next(true);
    }

    setPreset(preset: string): void {
        this.layoutConfig.update((state) => ({ ...state, preset }));
        
        // Solo guardar en empresa si estamos en contexto de empresa
        if (this.isCompanyContext()) {
            this.updateCompanyTheme({ themePreset: preset });
        } else {
            // Guardar en localStorage para cambios de usuario
            localStorage.setItem('theme-preset', preset);
        }
    }

    setPrimaryColor(color: string): void {
        this.layoutConfig.update((state) => ({ ...state, primary: color }));
        
        // Solo guardar en empresa si estamos en contexto de empresa
        if (this.isCompanyContext()) {
            this.updateCompanyTheme({ themePrimary: color });
        } else {
            // Guardar en localStorage para cambios de usuario
            localStorage.setItem('theme-primary', color);
        }
    }

    setSurfaceColor(color: string): void {
        this.layoutConfig.update((state) => ({ ...state, surface: color }));
        
        // Solo guardar en empresa si estamos en contexto de empresa
        if (this.isCompanyContext()) {
            this.updateCompanyTheme({ themeSurface: color });
        } else {
            // Guardar en localStorage para cambios de usuario
            localStorage.setItem('theme-surface', color);
        }
    }

    setThemeMode(mode: 'light' | 'dark'): void {
        const isDark = mode === 'dark';
        // Actualizar el estado de una sola vez
        this.layoutConfig.update(state => ({
            ...state,
            darkTheme: isDark
        }));
        
        // El efecto reactivo se encargarÃ¡ de actualizar el DOM y localStorage
        console.log('ðŸŒ™ Modo de tema establecido a:', mode);
    }

    setMenuMode(mode: 'static' | 'overlay'): void {
        this.layoutConfig.update((state) => ({ ...state, menuMode: mode }));
        
        // Solo guardar en empresa si estamos en contexto de empresa
        if (this.isCompanyContext()) {
            this.updateCompanyTheme({ menuMode: mode });
        } else {
            // Guardar en localStorage para cambios de usuario
            localStorage.setItem('theme-menu-mode', mode);
        }
    }

    private updateCompanyTheme(themeUpdate: any): void {
        const companyId = this.currentCompanyId();
        if (companyId && this.isCompanyContext()) {
            const currentTheme = this.companyThemeService.getCurrentTheme();
            const updatedTheme = { ...currentTheme, ...themeUpdate };
            
            this.companyThemeService.updateThemeSettings(companyId, updatedTheme).subscribe({
                next: () => {
                    console.log('Estilos de empresa actualizados correctamente');
                },
                error: (error) => {
                    console.error('Error al actualizar estilos de empresa:', error);
                    // Fallback: guardar en localStorage
                    this.saveToLocalStorage(themeUpdate);
                }
            });
        } else {
            // Fallback: guardar en localStorage si no hay empresa
            this.saveToLocalStorage(themeUpdate);
        }
    }

    private saveToLocalStorage(themeUpdate: any): void {
        if (themeUpdate.themePreset) {
            localStorage.setItem('theme-preset', themeUpdate.themePreset);
        }
        if (themeUpdate.themePrimary) {
            localStorage.setItem('theme-primary', themeUpdate.themePrimary);
        }
        if (themeUpdate.themeSurface) {
            localStorage.setItem('theme-surface', themeUpdate.themeSurface);
        }
        // themeMode se maneja por separado como preferencia personal
    }
}
